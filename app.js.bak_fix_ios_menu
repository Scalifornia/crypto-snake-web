(() => {
  "use strict";

  const el = {
    canvas: document.getElementById("game"),
    menu: document.getElementById("menu"),
    overlay: document.getElementById("overlay"),
    overlayTitle: document.getElementById("overlayTitle"),
    overlayText: document.getElementById("overlayText"),

    btnPlay: document.getElementById("btnPlay"),
    btnPause: document.getElementById("btnPause"),
    btnReset: document.getElementById("btnReset"),
    btnMenu: document.getElementById("btnMenu"),

    btnOverlayResume: document.getElementById("btnOverlayResume"),
    btnOverlayReset: document.getElementById("btnOverlayReset"),
    btnOverlayMenu: document.getElementById("btnOverlayMenu"),

    mode: document.getElementById("mode"),
    difficulty: document.getElementById("difficulty"),
    walls: document.getElementById("walls"),
    grid: document.getElementById("grid"),

    bgOpacity: document.getElementById("bgOpacity"),
    bgFile: document.getElementById("bgFile"),

    sound: document.getElementById("sound"),
    sfxVol: document.getElementById("sfxVol"),

    music: document.getElementById("music"),
    musicTrack: document.getElementById("musicTrack"),
    musicVol: document.getElementById("musicVol"),

    score: document.getElementById("score"),
    best: document.getElementById("best"),
  };

  if (!el.canvas) return;
  const ctx = el.canvas.getContext("2d", { alpha: false });

  // ---------- CONFIG ----------
  const STORAGE_KEY = "cryptoSnakeBest_v5";
  const LS = {
    sfxVol: "cs_sfxVol",
    musicVol: "cs_musicVol",
    musicTrack: "cs_musicTrack",
    bgData: "cs_bgData",
    bgOpacity: "cs_bgOpacity",
    grid: "cs_grid",
    walls: "cs_walls",
    difficulty: "cs_difficulty",
    mode: "cs_mode",
  };

  const GRID = 22;

  const DIFFICULTY = {
    easy: { tickMs: 140 },
    normal: { tickMs: 110 },
    hard: { tickMs: 85 },
  };

  const State = { MENU:"MENU", RUNNING:"RUNNING", PAUSED:"PAUSED", OVER:"OVER" };
  let state = State.MENU;

  let rafId = null;
  let lastTs = 0;
  let accMs = 0;

  let tickMs = DIFFICULTY.normal.tickMs;
  let speedMult = 1.0;

  let timeLeft = 60;
  let lastSecondTs = 0;

  let wallsOn = false;

  let snake = [];
  let dir = { x: 1, y: 0 };
  let nextDir = { x: 1, y: 0 };
  let food = { x: 10, y: 10 };

  let score = 0;
  let best = Number(localStorage.getItem(STORAGE_KEY) || 0);
  el.best && (el.best.textContent = String(best));

  // ---------- CANVAS LAYOUT (board quadrado) ----------
  let cssW = 800, cssH = 600, dpr = 1;
  let cell = 20, boardPx = 440, ox = 0, oy = 0;

  function resizeCanvas() {
    const rect = el.canvas.getBoundingClientRect();
    cssW = Math.max(1, rect.width);
    cssH = Math.max(1, rect.height);
    dpr = Math.max(1, window.devicePixelRatio || 1);

    el.canvas.width = Math.floor(cssW * dpr);
    el.canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    boardPx = Math.floor(Math.min(cssW, cssH));
    cell = Math.max(10, Math.floor(boardPx / GRID));
    boardPx = cell * GRID;

    ox = Math.floor((cssW - boardPx) / 2);
    oy = Math.floor((cssH - boardPx) / 2);
  }
  window.addEventListener("resize", resizeCanvas, { passive: true });
  resizeCanvas();

  // ---------- AUDIO ----------
  const sfx = {
    eat: new Audio("assets/audio/som_comer.wav"),
    dead: new Audio("assets/audio/som_perder.wav"),
    level: new Audio("assets/audio/level_up.wav"),
  };
  Object.values(sfx).forEach(a => a.addEventListener("error", () => {}, { once: true }));

  let music = new Audio(el.musicTrack?.value || "assets/audio/trilha_sonora.wav");
  music.loop = true;
  music.addEventListener("error", () => {}, { once: true });

  let audioUnlocked = false;

  function sfxVolume() {
    const v = Number(el.sfxVol?.value ?? 80);
    return Math.max(0, Math.min(1, v / 100));
  }
  function musicVolume() {
    const v = Number(el.musicVol?.value ?? 60);
    return Math.max(0, Math.min(1, v / 100));
  }
  function shouldSfx() { return el.sound?.value === "on"; }
  function shouldMusic() { return el.music?.value === "on"; }

  function unlockAudioOnce() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    // iOS unlock
    try {
      music.volume = 0;
      music.play().then(() => {
        music.pause();
        music.currentTime = 0;
        music.volume = musicVolume();
      }).catch(() => {});
    } catch {}
  }

  function playSfx(aud) {
    if (!shouldSfx()) return;
    try {
      aud.volume = sfxVolume();
      aud.currentTime = 0;
      aud.play().catch(() => {});
    } catch {}
  }

  function musicStop() {
    try { music.pause(); } catch {}
  }

  function musicStartIfNeeded() {
    if (!shouldMusic()) { musicStop(); return; }
    try {
      music.volume = musicVolume();
      music.play().catch(() => {});
    } catch {}
  }

  function setMusicTrack(src) {
    try { musicStop(); } catch {}
    music = new Audio(src);
    music.loop = true;
    music.addEventListener("error", () => {}, { once: true });
    if (audioUnlocked) musicStartIfNeeded();
  }

  // ---------- BACKGROUND (custom) ----------
  let bgImg = null;

  function loadBgFromStorage() {
    const data = localStorage.getItem(LS.bgData);
    if (!data) { bgImg = null; return; }
    const img = new Image();
    img.onload = () => { bgImg = img; };
    img.src = data;
  }

  function setBgOpacityFromUI() {
    const v = Number(el.bgOpacity?.value ?? 40);
    localStorage.setItem(LS.bgOpacity, String(v));
  }

  function bgOpacity() {
    const v = Number(el.bgOpacity?.value ?? localStorage.getItem(LS.bgOpacity) ?? 40);
    return Math.max(0, Math.min(1, v / 100));
  }

  // ---------- GRID OPACITY ----------
  function gridAlpha() {
    const mode = el.grid?.value || "off";
    if (mode === "off") return 0;
    if (mode === "mid") return 0.10;
    return 0.05;
  }

  // ---------- UI ----------
  function showMenu(show) { el.menu?.classList.toggle("hidden", !show); }
  function showOverlay(show, title = "", text = "") {
    if (!el.overlay) return;
    el.overlay.classList.toggle("hidden", !show);
    if (show) {
      el.overlayTitle.textContent = title;
      el.overlayText.textContent = text;
    }
  }

  function syncHud() {
    el.score && (el.score.textContent = String(score));
    el.best && (el.best.textContent = String(best));
  }

  // ---------- GAME ----------
  function spawnFood() {
    for (let tries = 0; tries < 5000; tries++) {
      const x = Math.floor(Math.random() * GRID);
      const y = Math.floor(Math.random() * GRID);
      const blocked = snake.some(p => p.x === x && p.y === y);
      if (!blocked) { food = { x, y }; return; }
    }
    food = { x: 1, y: 1 };
  }

  function initGameFromMenu() {
    const diff = DIFFICULTY[el.difficulty?.value] || DIFFICULTY.normal;
    tickMs = diff.tickMs;

    score = 0;
    speedMult = 1.0;
    dir = { x: 1, y: 0 };
    nextDir = { x: 1, y: 0 };

    wallsOn = (el.walls?.value === "on");
    if (el.mode?.value === "classic" && el.walls?.value === "off") wallsOn = false;

    const mid = Math.floor(GRID / 2);
    snake = [
      { x: mid, y: mid },
      { x: mid - 1, y: mid },
      { x: mid - 2, y: mid },
    ];

    if (el.mode?.value === "timed") {
      timeLeft = 60;
      lastSecondTs = 0;
    }

    spawnFood();
    lastTs = 0;
    accMs = 0;
    syncHud();
  }

  function setNextDir(x, y) {
    if (x === -dir.x && y === -dir.y) return;
    nextDir = { x, y };
  }

  function step() {
    dir = nextDir;

    const head = snake[0];
    const newHead = { x: head.x + dir.x, y: head.y + dir.y };

    if (wallsOn) {
      if (newHead.x < 0 || newHead.y < 0 || newHead.x >= GRID || newHead.y >= GRID) {
        gameOver("Bateu na parede.");
        return;
      }
    } else {
      newHead.x = (newHead.x + GRID) % GRID;
      newHead.y = (newHead.y + GRID) % GRID;
    }

    if (snake.some(p => p.x === newHead.x && p.y === newHead.y)) {
      gameOver("Colisão com o corpo.");
      return;
    }

    snake.unshift(newHead);

    if (newHead.x === food.x && newHead.y === food.y) {
      score += 10;
      playSfx(sfx.eat);
      spawnFood();

      if (el.mode?.value === "survival") {
        const before = speedMult;
        speedMult = Math.min(2.5, speedMult + 0.05);
        if (speedMult > before + 1e-9) playSfx(sfx.level);
      }

      syncHud();
    } else {
      snake.pop();
    }
  }

  function gameOver(msg) {
    state = State.OVER;
    stopLoop();
    playSfx(sfx.dead);

    if (score > best) {
      best = score;
      localStorage.setItem(STORAGE_KEY, String(best));
    }
    syncHud();
    showOverlay(true, "Game Over", msg || "Reset ou Menu.");
    draw();
  }

  // ---------- TOUCH CONTROL (ANYWHERE) ----------
  // Estratégia: seguir o dedo se estiver pressionado.
  // E permitir “deslizar” (touchmove) para mudar direção rápido.
  let activeTouchId = null;
  let followPoint = null;

  function clientToCanvas(clientX, clientY) {
    const rect = el.canvas.getBoundingClientRect();
    const cx = Math.min(rect.right, Math.max(rect.left, clientX));
    const cy = Math.min(rect.bottom, Math.max(rect.top, clientY));
    const x = (cx - rect.left) * (cssW / rect.width);
    const y = (cy - rect.top) * (cssH / rect.height);
    return { x, y };
  }

  function updateDirTowardFollowPoint() {
    if (!followPoint || state !== State.RUNNING) return;

    const head = snake[0];
    const headPx = { x: ox + head.x * cell + cell / 2, y: oy + head.y * cell + cell / 2 };
    const dx = followPoint.x - headPx.x;
    const dy = followPoint.y - headPx.y;

    const ax = Math.abs(dx), ay = Math.abs(dy);

    // Mais responsivo no mobile: escolher eixo dominante sem “travões”
    if (ax >= ay) setNextDir(dx > 0 ? 1 : -1, 0);
    else setNextDir(0, dy > 0 ? 1 : -1);
  }

  function onTouchStart(e) {
    unlockAudioOnce();
    if (e.touches.length === 0) return;
    const t = e.touches[0];
    activeTouchId = t.identifier;
    followPoint = clientToCanvas(t.clientX, t.clientY);
    e.preventDefault();
  }

  function findActiveTouch(touches) {
    if (activeTouchId === null) return null;
    for (let i = 0; i < touches.length; i++) {
      if (touches[i].identifier === activeTouchId) return touches[i];
    }
    return null;
  }

  function onTouchMove(e) {
    const t = findActiveTouch(e.touches) || (e.touches.length ? e.touches[0] : null);
    if (!t) return;
    followPoint = clientToCanvas(t.clientX, t.clientY);
    e.preventDefault();
  }

  function onTouchEnd(e) {
    // se acabou o toque ativo, limpa
    const still = findActiveTouch(e.touches);
    if (!still) {
      activeTouchId = null;
      followPoint = null;
    }
    e.preventDefault();
  }

  // também suporta pointer (android/desktop), mas o touch é o principal no iOS
  let activePointerId = null;
  function onPointerDown(e) {
    unlockAudioOnce();
    // evitar “seguir rato” no mac
    if (e.pointerType === "mouse") return;
    activePointerId = e.pointerId;
    followPoint = clientToCanvas(e.clientX, e.clientY);
  }
  function onPointerMove(e) {
    if (activePointerId === null) return;
    if (e.pointerId !== activePointerId) return;
    followPoint = clientToCanvas(e.clientX, e.clientY);
  }
  function onPointerUp(e) {
    if (activePointerId === null) return;
    if (e.pointerId !== activePointerId) return;
    activePointerId = null;
    followPoint = null;
  }

  document.addEventListener("touchstart", onTouchStart, { passive: false });
  document.addEventListener("touchmove", onTouchMove, { passive: false });
  document.addEventListener("touchend", onTouchEnd, { passive: false });
  document.addEventListener("touchcancel", onTouchEnd, { passive: false });

  document.addEventListener("pointerdown", onPointerDown, { passive: true });
  document.addEventListener("pointermove", onPointerMove, { passive: true });
  document.addEventListener("pointerup", onPointerUp, { passive: true });
  document.addEventListener("pointercancel", onPointerUp, { passive: true });

  // ---------- LOOP ----------
  function startLoop() {
    stopLoop();
    rafId = requestAnimationFrame(loop);
  }
  function stopLoop() {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
  }

  function loop(ts) {
    if (state !== State.RUNNING) return;

    if (!lastTs) lastTs = ts;
    const dt = ts - lastTs;
    lastTs = ts;
    accMs += dt;

    updateDirTowardFollowPoint();

    if (el.mode?.value === "timed") {
      if (!lastSecondTs) lastSecondTs = ts;
      if (ts - lastSecondTs >= 1000) {
        lastSecondTs += 1000;
        timeLeft -= 1;
        if (timeLeft <= 0) { gameOver("Tempo esgotado."); return; }
      }
    }

    const effectiveTick = tickMs / speedMult;
    while (accMs >= effectiveTick) {
      accMs -= effectiveTick;
      step();
      if (state !== State.RUNNING) return;
    }

    draw();
    rafId = requestAnimationFrame(loop);
  }

  // ---------- RENDER ----------
  function drawBackground() {
    ctx.fillStyle = "#050812";
    ctx.fillRect(0, 0, cssW, cssH);

    // board area
    ctx.fillStyle = "#070a12";
    ctx.fillRect(ox, oy, boardPx, boardPx);

    // custom background
    if (bgImg) {
      const a = bgOpacity();
      if (a > 0) {
        ctx.save();
        ctx.globalAlpha = a;
        ctx.drawImage(bgImg, ox, oy, boardPx, boardPx);
        ctx.restore();
      }
    }

    // grid opacity (off/mid/low)
    const ga = gridAlpha();
    if (ga > 0) {
      ctx.strokeStyle = `rgba(255,255,255,${ga})`;
      ctx.lineWidth = 1;
      for (let i = 0; i <= GRID; i++) {
        const x = ox + i * cell;
        const y = oy + i * cell;
        ctx.beginPath(); ctx.moveTo(x, oy); ctx.lineTo(x, oy + boardPx); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ox, y); ctx.lineTo(ox + boardPx, y); ctx.stroke();
      }
    }

    // neon border if walls on
    if (wallsOn) {
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(57,255,221,0.85)";
      ctx.strokeRect(ox + 2, oy + 2, boardPx - 4, boardPx - 4);
      ctx.lineWidth = 1;
    }
  }

  function drawFood() {
    const x = ox + food.x * cell;
    const y = oy + food.y * cell;
    ctx.fillStyle = "rgba(34,197,94,0.95)";
    ctx.fillRect(x + 3, y + 3, cell - 6, cell - 6);
  }

  function drawSnake() {
    for (let i = snake.length - 1; i >= 0; i--) {
      const p = snake[i];
      const x = ox + p.x * cell;
      const y = oy + p.y * cell;

      if (i === 0) {
        ctx.fillStyle = "rgba(57,255,221,0.92)";
        ctx.fillRect(x + 1, y + 1, cell - 2, cell - 2);
        ctx.fillStyle = "rgba(168,85,247,0.18)";
        ctx.fillRect(x + 5, y + 5, cell - 10, cell - 10);
      } else {
        ctx.fillStyle = "rgba(168,85,247,0.45)";
        ctx.fillRect(x + 2, y + 2, cell - 4, cell - 4);
      }
    }
  }

  function draw() {
    drawBackground();
    drawFood();
    drawSnake();
  }

  // ---------- CONTROLS ----------
  function startGame() {
    unlockAudioOnce();
    resizeCanvas();
    initGameFromMenu();
    state = State.RUNNING;

    showMenu(false);
    showOverlay(false);

    musicStartIfNeeded();
    startLoop();
  }

  function pauseToggle(force) {
    if (state !== State.RUNNING && state !== State.PAUSED) return;
    const toPause = typeof force === "boolean" ? force : (state === State.RUNNING);

    if (toPause) {
      state = State.PAUSED;
      stopLoop();
      musicStop();
      showOverlay(true, "Pausa", "Espaço para continuar · R para reset");
      el.btnPause && (el.btnPause.textContent = "Resume");
    } else {
      state = State.RUNNING;
      showOverlay(false);
      el.btnPause && (el.btnPause.textContent = "Pause");
      musicStartIfNeeded();
      startLoop();
    }
  }

  function reset() {
    if (state === State.MENU) return;
    startGame();
  }

  function backToMenu() {
    stopLoop();
    musicStop();
    state = State.MENU;
    showOverlay(false);
    showMenu(true);
    el.btnPause && (el.btnPause.textContent = "Pause");
    resizeCanvas();
    drawBackground();
  }

  // Keyboard (PC)
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === " " || k === "spacebar") { e.preventDefault(); pauseToggle(); return; }
    if (k === "r") { reset(); return; }
    if (state !== State.RUNNING) return;

    if (k === "arrowup" || k === "w") setNextDir(0, -1);
    else if (k === "arrowdown" || k === "s") setNextDir(0, 1);
    else if (k === "arrowleft" || k === "a") setNextDir(-1, 0);
    else if (k === "arrowright" || k === "d") setNextDir(1, 0);
  });

  // UI buttons
  el.btnPlay?.addEventListener("click", startGame);
  el.btnPause?.addEventListener("click", () => pauseToggle());
  el.btnReset?.addEventListener("click", reset);
  el.btnMenu?.addEventListener("click", backToMenu);

  el.btnOverlayResume?.addEventListener("click", () => pauseToggle(false));
  el.btnOverlayReset?.addEventListener("click", reset);
  el.btnOverlayMenu?.addEventListener("click", backToMenu);

  // Settings persistence
  function applySavedSettingsToUI() {
    const setIf = (node, key) => {
      const v = localStorage.getItem(key);
      if (node && v !== null) node.value = v;
    };
    setIf(el.sfxVol, LS.sfxVol);
    setIf(el.musicVol, LS.musicVol);
    setIf(el.musicTrack, LS.musicTrack);
    setIf(el.bgOpacity, LS.bgOpacity);
    setIf(el.grid, LS.grid);
    setIf(el.walls, LS.walls);
    setIf(el.difficulty, LS.difficulty);
    setIf(el.mode, LS.mode);
  }

  function wireSettingsSave() {
    const saveVal = (node, key) => node?.addEventListener("change", () => localStorage.setItem(key, String(node.value)));
    const saveInput = (node, key) => node?.addEventListener("input", () => localStorage.setItem(key, String(node.value)));

    saveInput(el.sfxVol, LS.sfxVol);
    saveInput(el.musicVol, LS.musicVol);
    saveVal(el.musicTrack, LS.musicTrack);
    saveInput(el.bgOpacity, LS.bgOpacity);
    saveVal(el.grid, LS.grid);
    saveVal(el.walls, LS.walls);
    saveVal(el.difficulty, LS.difficulty);
    saveVal(el.mode, LS.mode);

    el.musicTrack?.addEventListener("change", () => {
      localStorage.setItem(LS.musicTrack, el.musicTrack.value);
      setMusicTrack(el.musicTrack.value);
    });

    el.musicVol?.addEventListener("input", () => {
      localStorage.setItem(LS.musicVol, el.musicVol.value);
      if (audioUnlocked) musicStartIfNeeded();
    });

    el.music?.addEventListener("change", () => {
      if (audioUnlocked) musicStartIfNeeded();
    });

    el.bgOpacity?.addEventListener("input", setBgOpacityFromUI);

    el.bgFile?.addEventListener("change", async () => {
      const f = el.bgFile.files && el.bgFile.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        const data = String(reader.result || "");
        localStorage.setItem(LS.bgData, data);
        loadBgFromStorage();
      };
      reader.readAsDataURL(f);
    });
  }

  // ---------- BOOT ----------
  applySavedSettingsToUI();

  // carregar BG custom se existir
  loadBgFromStorage();

  // aplicar music track guardada
  const savedTrack = localStorage.getItem(LS.musicTrack);
  if (savedTrack && el.musicTrack) {
    el.musicTrack.value = savedTrack;
    setMusicTrack(savedTrack);
  }

  wireSettingsSave();

  showOverlay(false);
  showMenu(true);
  resizeCanvas();
  syncHud();
  drawBackground();
})();
