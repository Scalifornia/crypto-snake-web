(() => {
  "use strict";

  // ---------- DOM ----------
  const el = {
    canvas: document.getElementById("game"),
    menu: document.getElementById("menu"),
    overlay: document.getElementById("overlay"),
    overlayTitle: document.getElementById("overlayTitle"),
    overlayText: document.getElementById("overlayText"),
    btnPlay: document.getElementById("btnPlay"),
    btnPause: document.getElementById("btnPause"),
    btnReset: document.getElementById("btnReset"),
    btnMenu: document.getElementById("btnMenu"),
    btnOverlayResume: document.getElementById("btnOverlayResume"),
    btnOverlayReset: document.getElementById("btnOverlayReset"),
    btnOverlayMenu: document.getElementById("btnOverlayMenu"),
    mode: document.getElementById("mode"),
    difficulty: document.getElementById("difficulty"),
    sound: document.getElementById("sound"),
    score: document.getElementById("score"),
    best: document.getElementById("best"),
    hudMode: document.getElementById("hudMode"),
    hudSpeed: document.getElementById("hudSpeed"),
    timerBox: document.getElementById("timerBox"),
    timer: document.getElementById("timer"),
  };

  if (!el.canvas) return;
  const ctx = el.canvas.getContext("2d", { alpha: false });

  // ---------- CONFIG ----------
  const STORAGE_KEY = "cryptoSnakeBest_v3";

  const DIFFICULTY = {
    easy: { tickMs: 140 },
    normal: { tickMs: 110 },
    hard: { tickMs: 85 },
  };

  const State = {
    MENU: "MENU",
    RUNNING: "RUNNING",
    PAUSED: "PAUSED",
    OVER: "OVER",
  };

  // Tabuleiro (células). Mantemos quadrado sempre.
  const GRID_CELLS = 22;

  // ---------- AUDIO ----------
  const sounds = {
    click: new Audio("assets/audio/level_up.wav"),
    eat: new Audio("assets/audio/som_comer.wav"),
    dead: new Audio("assets/audio/som_perder.wav"),
  };
  for (const k of Object.keys(sounds)) sounds[k].addEventListener("error", () => {}, { once: true });

  function playSound(name) {
    if (!el.sound || el.sound.value !== "on") return;
    const a = sounds[name];
    if (!a) return;
    try { a.currentTime = 0; a.play().catch(() => {}); } catch {}
  }

  // ---------- STATE ----------
  let state = State.MENU;

  let rafId = null;
  let lastTs = 0;
  let accMs = 0;

  let tickMs = DIFFICULTY.normal.tickMs;
  let speedMult = 1.0;

  let timeLeft = 60;
  let lastSecondTs = 0;

  let snake = [];
  let dir = { x: 1, y: 0 };
  let nextDir = { x: 1, y: 0 };
  let food = { x: 10, y: 10 };

  let score = 0;
  let best = Number(localStorage.getItem(STORAGE_KEY) || 0);
  if (el.best) el.best.textContent = String(best);

  // ---------- CANVAS / BOARD LAYOUT ----------
  let cssW = 800, cssH = 500;     // tamanho visível (CSS px)
  let dpr = 1;
  let cell = 20;                 // px por célula (sempre quadrado)
  let boardSizePx = 440;         // px do tabuleiro (quadrado)
  let ox = 0, oy = 0;            // offsets do tabuleiro dentro do canvas

  function resizeCanvas() {
    const rect = el.canvas.getBoundingClientRect();
    cssW = Math.max(1, rect.width);
    cssH = Math.max(1, rect.height);
    dpr = Math.max(1, window.devicePixelRatio || 1);

    el.canvas.width = Math.floor(cssW * dpr);
    el.canvas.height = Math.floor(cssH * dpr);

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // cell size baseado no menor lado -> tabuleiro quadrado, sem esticar
    boardSizePx = Math.floor(Math.min(cssW, cssH));
    cell = Math.max(10, Math.floor(boardSizePx / GRID_CELLS));
    boardSizePx = cell * GRID_CELLS;

    ox = Math.floor((cssW - boardSizePx) / 2);
    oy = Math.floor((cssH - boardSizePx) / 2);
  }

  window.addEventListener("resize", resizeCanvas, { passive: true });
  resizeCanvas();

  // ---------- UI ----------
  function showMenu(show) { if (el.menu) el.menu.classList.toggle("hidden", !show); }
  function showOverlay(show, title = "", text = "") {
    if (!el.overlay) return;
    el.overlay.classList.toggle("hidden", !show);
    if (show) {
      if (el.overlayTitle) el.overlayTitle.textContent = title;
      if (el.overlayText) el.overlayText.textContent = text;
    }
  }

  function syncHud() {
    if (el.score) el.score.textContent = String(score);
    if (el.best) el.best.textContent = String(best);
    if (el.hudMode && el.mode) el.hudMode.textContent = el.mode.value;
    if (el.hudSpeed) el.hudSpeed.textContent = `${speedMult.toFixed(1)}x`;

    const isTimed = el.mode && el.mode.value === "timed";
    if (el.timerBox) el.timerBox.classList.toggle("hidden", !isTimed);
    if (isTimed && el.timer) el.timer.textContent = String(timeLeft);
  }

  // ---------- GAME ----------
  function spawnFood() {
    for (let tries = 0; tries < 5000; tries++) {
      const x = Math.floor(Math.random() * GRID_CELLS);
      const y = Math.floor(Math.random() * GRID_CELLS);
      const blocked = snake.some(p => p.x === x && p.y === y);
      if (!blocked) { food = { x, y }; return; }
    }
    food = { x: 1, y: 1 };
  }

  function initGame() {
    const diff = DIFFICULTY[el.difficulty?.value] || DIFFICULTY.normal;
    tickMs = diff.tickMs;
    speedMult = 1.0;

    score = 0;
    dir = { x: 1, y: 0 };
    nextDir = { x: 1, y: 0 };

    const mid = Math.floor(GRID_CELLS / 2);
    snake = [
      { x: mid, y: mid },
      { x: mid - 1, y: mid },
      { x: mid - 2, y: mid },
    ];

    if (el.mode?.value === "timed") {
      timeLeft = 60;
      lastSecondTs = 0;
    }

    spawnFood();

    lastTs = 0;
    accMs = 0;
    syncHud();
  }

  function setNextDir(x, y) {
    if (x === -dir.x && y === -dir.y) return;
    nextDir = { x, y };
  }

  function step() {
    dir = nextDir;

    const head = snake[0];
    const newHead = { x: head.x + dir.x, y: head.y + dir.y };

    if (newHead.x < 0 || newHead.y < 0 || newHead.x >= GRID_CELLS || newHead.y >= GRID_CELLS) {
      gameOver("Bateu na parede.");
      return;
    }

    if (snake.some(p => p.x === newHead.x && p.y === newHead.y)) {
      gameOver("Colisão com o corpo.");
      return;
    }

    snake.unshift(newHead);

    if (newHead.x === food.x && newHead.y === food.y) {
      score += 10;
      playSound("eat");
      spawnFood();

      if (el.mode?.value === "survival") speedMult = Math.min(2.5, speedMult + 0.05);
      syncHud();
    } else {
      snake.pop();
    }
  }

  function gameOver(msg) {
    state = State.OVER;
    stopLoop();
    playSound("dead");

    if (score > best) {
      best = score;
      localStorage.setItem(STORAGE_KEY, String(best));
    }
    syncHud();
    showOverlay(true, "Game Over", msg || "Reset ou Menu.");
    draw();
  }

  // ---------- FOLLOW FINGER (em qualquer parte do ecrã) ----------
  let followEnabled = true;
  let followPoint = null;
  let activePointerId = null;

  function clientToBoardPoint(clientX, clientY) {
    const rect = el.canvas.getBoundingClientRect();

    // clamp ao rect do canvas
    const cx = Math.min(rect.right, Math.max(rect.left, clientX));
    const cy = Math.min(rect.bottom, Math.max(rect.top, clientY));

    const x = (cx - rect.left) * (cssW / rect.width);
    const y = (cy - rect.top) * (cssH / rect.height);
    return { x, y };
  }

  function updateDirTowardFollowPoint() {
    if (!followPoint || state !== State.RUNNING) return;

    const head = snake[0];
    const headPx = { x: ox + head.x * cell + cell / 2, y: oy + head.y * cell + cell / 2 };

    const dx = followPoint.x - headPx.x;
    const dy = followPoint.y - headPx.y;

    // Histerese ligeira para não tremer
    const ax = Math.abs(dx), ay = Math.abs(dy);
    if (ax > ay * 1.15) setNextDir(dx > 0 ? 1 : -1, 0);
    else if (ay > ax * 1.15) setNextDir(0, dy > 0 ? 1 : -1);
    else {
      // empate: mantém eixo atual
      if (dir.x !== 0) setNextDir(dir.x, 0);
      else setNextDir(0, dir.y);
    }
  }

  // Pointer em qualquer parte do ecrã (document)
  function onPointerDown(e) {
    if (!followEnabled) return;
    activePointerId = e.pointerId;
    followPoint = clientToBoardPoint(e.clientX, e.clientY);
  }

  function onPointerMove(e) {
    if (!followEnabled) return;
    if (activePointerId !== null && e.pointerId !== activePointerId) return;
    followPoint = clientToBoardPoint(e.clientX, e.clientY);
  }

  function onPointerUp(e) {
    if (activePointerId !== null && e.pointerId !== activePointerId) return;
    activePointerId = null;
    // Continua a andar na direção atual (não “para” quando levanta)
    followPoint = null;
  }

  // iOS: usar passive:false para conseguir evitar scroll (mesmo com overflow hidden)
  document.addEventListener("pointerdown", onPointerDown, { passive: false });
  document.addEventListener("pointermove", onPointerMove, { passive: false });
  document.addEventListener("pointerup", onPointerUp, { passive: false });
  document.addEventListener("pointercancel", onPointerUp, { passive: false });

  // ---------- LOOP ----------
  function startLoop() {
    stopLoop();
    rafId = requestAnimationFrame(loop);
  }
  function stopLoop() {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
  }

  function loop(ts) {
    if (state !== State.RUNNING) return;

    if (!lastTs) lastTs = ts;
    const dt = ts - lastTs;
    lastTs = ts;
    accMs += dt;

    // follow finger: atualiza direção continuamente
    updateDirTowardFollowPoint();

    // timed mode
    if (el.mode?.value === "timed") {
      if (!lastSecondTs) lastSecondTs = ts;
      if (ts - lastSecondTs >= 1000) {
        lastSecondTs += 1000;
        timeLeft -= 1;
        if (timeLeft <= 0) { gameOver("Tempo esgotado."); return; }
        syncHud();
      }
    }

    const effectiveTick = tickMs / speedMult;
    while (accMs >= effectiveTick) {
      accMs -= effectiveTick;
      step();
      if (state !== State.RUNNING) return;
    }

    draw();
    rafId = requestAnimationFrame(loop);
  }

  // ---------- RENDER ----------
  function drawBackground() {
    ctx.fillStyle = "#050812";
    ctx.fillRect(0, 0, cssW, cssH);

    // área do tabuleiro
    ctx.fillStyle = "#070a12";
    ctx.fillRect(ox, oy, boardSizePx, boardSizePx);

    // grelha subtil
    ctx.strokeStyle = "rgba(255,255,255,0.05)";
    ctx.lineWidth = 1;
    for (let i = 0; i <= GRID_CELLS; i++) {
      const x = ox + i * cell;
      const y = oy + i * cell;

      ctx.beginPath(); ctx.moveTo(x, oy); ctx.lineTo(x, oy + boardSizePx); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox, y); ctx.lineTo(ox + boardSizePx, y); ctx.stroke();
    }
  }

  function drawFood() {
    const x = ox + food.x * cell;
    const y = oy + food.y * cell;
    ctx.fillStyle = "rgba(255,213,79,0.95)";
    ctx.fillRect(x + 3, y + 3, cell - 6, cell - 6);
  }

  function drawSnake() {
    for (let i = snake.length - 1; i >= 0; i--) {
      const p = snake[i];
      const x = ox + p.x * cell;
      const y = oy + p.y * cell;

      if (i === 0) {
        ctx.fillStyle = "rgba(74,163,255,0.95)";
        ctx.fillRect(x + 1, y + 1, cell - 2, cell - 2);
        ctx.fillStyle = "rgba(255,255,255,0.12)";
        ctx.fillRect(x + 5, y + 5, cell - 10, cell - 10);
      } else {
        ctx.fillStyle = "rgba(124,92,255,0.55)";
        ctx.fillRect(x + 2, y + 2, cell - 4, cell - 4);
      }
    }
  }

  function draw() {
    drawBackground();
    drawFood();
    drawSnake();
  }

  // ---------- CONTROLS ----------
  function startGame() {
    playSound("click");
    resizeCanvas();
    initGame();
    state = State.RUNNING;
    showMenu(false);
    showOverlay(false);
    startLoop();
  }

  function pauseToggle(force) {
    if (state !== State.RUNNING && state !== State.PAUSED) return;

    const toPause = typeof force === "boolean" ? force : (state === State.RUNNING);
    if (toPause) {
      state = State.PAUSED;
      stopLoop();
      showOverlay(true, "Pausa", "Espaço para continuar · R para reset");
      if (el.btnPause) el.btnPause.textContent = "Resume";
    } else {
      state = State.RUNNING;
      showOverlay(false);
      if (el.btnPause) el.btnPause.textContent = "Pause";
      startLoop();
    }
  }

  function reset() {
    playSound("click");
    if (state === State.MENU) return;
    startGame();
  }

  function backToMenu() {
    stopLoop();
    state = State.MENU;
    showOverlay(false);
    showMenu(true);
    if (el.btnPause) el.btnPause.textContent = "Pause";
    resizeCanvas();
    drawBackground();
  }

  // Keyboard (Mac)
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();

    if (k === " " || k === "spacebar") { e.preventDefault(); pauseToggle(); return; }
    if (k === "r") { reset(); return; }

    if (state !== State.RUNNING) return;
    if (k === "arrowup" || k === "w") setNextDir(0, -1);
    else if (k === "arrowdown" || k === "s") setNextDir(0, 1);
    else if (k === "arrowleft" || k === "a") setNextDir(-1, 0);
    else if (k === "arrowright" || k === "d") setNextDir(1, 0);
  });

  // UI buttons
  el.btnPlay?.addEventListener("click", startGame);
  el.btnPause?.addEventListener("click", () => pauseToggle());
  el.btnReset?.addEventListener("click", reset);
  el.btnMenu?.addEventListener("click", backToMenu);

  el.btnOverlayResume?.addEventListener("click", () => pauseToggle(false));
  el.btnOverlayReset?.addEventListener("click", reset);
  el.btnOverlayMenu?.addEventListener("click", backToMenu);

  // ---------- BOOT ----------
  showOverlay(false);
  showMenu(true);
  resizeCanvas();
  syncHud();
  drawBackground();
})();
